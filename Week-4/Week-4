Exercise 4.1:

The task is to implement a function called `getNumber` that generates a random number. If the generated number is divisible by 5, the function should reject a custom promise. Otherwise, it should resolve the promise. The resolution/rejection time should be a variable.

To complete this exercise, we need to create a custom promise function that can handle all three states: resolved, rejected, and fulfilled. The function should also accept callbacks as parameters.

Here are the guidelines for this exercise:
1. JavaScript promises should not be used.
2. Third-party libraries should not be used.
3. Create a custom function with a meaningful name.
4. The program should execute without errors.
5. The program should achieve the desired result.
6. The program should handle all three states of a promise.
7. Commit the solution to Git with meaningful commit messages.

Outcome:
1. Gain an understanding of how promises work under the hood.
2. Learn to use the `bind` function to bind callback functions passed as parameters.
3. Understand the concept of a polyfill.
4. Handle errors using functions.

Exercise 4.2:

In this exercise, you need to create an object called `Teacher` derived from the `Person` class. Implement a method called `teach` that receives a string called `subject` and prints out "[teacher's name] is now teaching [subject]".

Here are the guidelines for this exercise:
1. The expected output should be achieved using the `prototype` keyword.
2. Reference: 
```
var Person = function() {};
Person.prototype.initialize = function(name, age) {
  this.name = name;
  this.age = age;
};
// TODO: create the class Teacher and a method teach
var him = new Teacher();
him.initialize("Adam", 45);
him.teach("Inheritance");
```

Outcome:
1. Understand how inheritance works in JavaScript.
2. Understand the purpose of the `prototype` keyword in JavaScript.

Exercise 4.3:

The task is to implement the Fibonacci series using iterators.

Sample output:

```
0
1
1
2
3
5
8
13
21
```

Here are the guidelines for this exercise:
1. The expected output should be achieved using iterators only.
2. For loops and maps should not be used.
3. Third-party libraries should not be used.

Outcome:
1. Understand how iterators work.
2. Understand the implementation of iterators under the hood.